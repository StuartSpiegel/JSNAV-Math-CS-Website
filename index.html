
<html>
<link rel="stylesheet" type="text/css" href="main.css">
<div class="wrapper active-element">
        <header class="main-header">
          <!-- Begin Menu -->
            <nav>
                <!-- Title -->
                <div class="masthead active-element">
                    <h1><a href="#0">Problems in Mathematics and Computer Science</a></h1>
                    <h3>By: Stuart Spiegel </h3>
                    <div id="menu-toggle" class="menu-toggle active-element">
                        <div class="one"></div>
                        <div class="two"></div>
                        <div class="three"></div>
                    </div>
                </div>
                <!-- END TITLE -->
                <div class="main-nav-list active-element">
                    <ul>
                        <li><a href="#0">Page 1</a></li>
                        <li><a href="#0">Page 2</a></li>
                        <li><a href="#0" class="mobile-hide">Page 3</a></li>
                        <li><a href="#0" class="active-link">Page 4</a></li>
                        <li><a href="#0">Page 5</a></li>
                    </ul>
                </div>
            </nav>
            <!-- End Menu -->
        </header>
        <!-- Start Body -->
              <br>
              <br>
              <br>
        <main class="main-contents">
            <!-- First Problem ***************************************************************************************************************************-->
            <h2>1.) Binary Representation of the Fibonacci Sequence</h2>
            <br>
            <p>
              <b>Objective:</b> To find the binary representation (or no. of 1's in binary representation) of nth term in Fibonacci sequence where n is of the order 10^6.
              My current approach: Find nth term (in decimal) in Fibonacci sequence using matrix exponentiation method and then convert the nth term to binary and then find number of 1's. <br>
              <br>
              <b>My question: Can this program be improved if I straight-away work with binary numbers? Is there a comparatively faster way to find nth term in Fibonacci sequence if we deal with binary numbers?</b><br>
              <br>
            </p>
 <!-- **************************************************************************************************************** -->
            <p>
              - You would bet there would be a direct binary way to calculate this, but currently there is none discovered
                <br>
              - The fastest way is somewhere around <em>O(log2n)</em> where a binary way may look more like <em>O(logn).</em> This comparison is like the difference between how fast computers can add numbers, and how fast computers can multiply (multiplying use normal school-based, like we do. There are more complex ways that are much faster). So essentially the following way is still pretty fast compared to a direct approach:
                <br>
              - Interestingly enough, instead of using F(n) in a binary way, the following algorithm uses n in binary.
                <br>
              - Take note of these basic properties of <em>Fibonacci numbers: </em>
                <br>
            ->  F(2k+1)=4(F(2k−F(2k−1)+2(−1)k)) <br>
            ->  F(2k−1)=F(2k)+F(2k−1) <br>
            ->  F(2k)=F(2k+1)−F(2k−1) <br>
              <b>**With these properties we can double the position of a Fibonacci number's index, instead of going one by one, which makes it so much faster. </b><br>
                <br>
                <br>
                <b>Steps:</b>
                <br>
                1.) Convert the n (as in F(n)) to binary. Example: The 11th Fibonacci number, so 11 in binary is 10112<br>
                2.) Have F(0)=0 and F(1()=1, and let k=1 to start. Lastly start from the 2nd binary digit place from the left. In this case it is the 0.<br>
                3.) Calculate (F(2k−1),F(2k),F(2k+1)) using the formulas listed above<br>
                4.) If the digit place is 0 use (F2k−1,F2k), if it is odd use (F2k,F2k+1) for the next values you substitute for (F(k−1),F(k)). Now shift the digit place one to the right.<br>
                5.) Repeat steps 3-4 until all the digits places are gone, and you will get your final Fibonacci number which will end up being whatever value you end up for your next Fk<br>
                <br>
                <br>
                <b>Example:</b>
                <br>
                <br>
              -->  To find F(13), n=13 in binary is 11012<br>
                -Starting from (F0,F1)=(0,1), the next value sets are: (12+02,F2k+1−F2k−1,4(1)2−02−2)=(1,2−1,2)=(1,1,2)<br>
                -Because the 2nd digit from the left is a 1, we will use (1,2) for our next values.<br>
                -Next values: (5,8,13). 3rd digit from the left is a 0 so we use (5,8). <br>
                -Next values: (89,144,233). 4th digit form the left is a 1 so we use (144,233), but that was the last digit place, so our answer is Fk, which is 233. <br>
                <br>
                <br>
                <b>Optimizations:</b>
              -->  Calculate F(2k) and F(2k−1) first and recycle them when calculating F(2k+1) and F(2k−1.) <br>
              -->  Because 2(−1)k is −2 when k is odd, and +2 when k is even, Whatever digit place read to determine what values to use for (Fk−1,Fk), also predicts which +2 or −2 to use. So in our example because we read a 1 in the 2nd place, we would use −2 for the next 2(−1)k. And because we read a 0 in the 3rd place, we would use +2 for the 2(−1)k after. So use a +2 if you read a 0, and use −2 if you read a 1.<br>

              </p>
              <br>
              <br>
              <br>
              <!--Start of 2nd problem -->
              <h2>2.) Knight's Tour </h2>
              <br>
              <br>
              <p>
              A knight's tour is a sequence of moves of a knight on a chessboard such that the knight visits every square only once. If the knight ends on a square that is one knight's move from the beginning square (so that it could tour the board again immediately, following the same path), the tour is closed; otherwise, it is open.
              <br>
              <br>
              Before we dive into the Knight Tour problem its important to understand the theory behind it. The Knight Tour problem is an instance of the more general Hamiltonian Path problem in graph theory.
              <br>
              <br>
              In the mathematical field of graph theory the Hamiltonian path problem and the Hamiltonian cycle problem are problems of determining whether a Hamiltonian path (a path in an undirected or directed graph that visits each vertex exactly once) or a Hamiltonian cycle exists in a given graph (whether directed or undirected). Both problems are NP-complete.
              <br>
              <em>The directed and undirected Hamiltonian cycle problems were two of Karp's 21 NP-complete problems. They remain NP-complete even for special kinds of graphs. </em> <br>
              <br>
              <br>
              Algorithmic Analysis: <em>There are n! different sequences of vertices that might be Hamiltonian paths in a given n-vertex graph</em> (and are, in a complete graph), so a brute force search algorithm that tests all possible sequences would be very slow.
              <br>
              <br>
              Dynamic Programming: <em>Also, a dynamic programming algorithm of Bellman, Held, and Karp can be used to solve the problem in time O(n2 2n).</em> In this method, one determines, for each set S of vertices and each vertex v in S, whether there is a path that covers exactly the vertices in S and ends at v. For each choice of S and v, a path exists for (S,v) if and only if v has a neighbor w such that a path exists for (S − v,w), which can be looked up from already-computed information in the dynamic program <br>
              <br>
              Reduction: In one direction, the Hamiltonian path problem for graph G is equivalent to the Hamiltonian cycle problem in a graph H obtained from G by adding a new vertex x and connecting x to all vertices of G. Thus, finding a Hamiltonian path cannot be significantly slower (in the worst case, as a function of the number of vertices) than finding a Hamiltonian cycle. <br>
              <br>
              In the other direction, the Hamiltonian cycle problem for a graph G is equivalent to the Hamiltonian path problem in the graph H obtained by copying one vertex v of G, v', that is, letting v' have the same neighbourhood as v, and by adding two dummy vertices of degree one, and connecting them with v and v', respectively.<br>
              <br>
              <br>
                Heuristic Based Algorithms: Warnsdorff’s algorithm <br>
              <br>
              <em>Warnsdorff’s Rule:</em>
              <br>
              We can start from any initial position of the knight on the board. <br>
              We always move to an adjacent, unvisited square with minimal degree (minimum number of unvisited adjacent). <br>
              This algorithm may also more generally be applied to any graph. <br>
              <br>
              Some definitions: <br>
              <br>
              A position Q is accessible from a position P if P can move to Q by a single Knight’s move, and Q has not yet been visited.
              The accessibility of a position P is the number of positions accessible from P.
              <br>
              <br>
              Algorithm:
              <br>
              <em>Steps</em> <br>
              <br>
              1.) Set P to be a random initial position on the board. <br>
              2.) Mark the board at P with the move number “1” <br>
              3.) Do following for each move number from 2 to the number of squares on the board: <br>
              4.) let S be the set of positions accessible from P. <br>
              5.) Set P to be the position in S with minimum accessibility <br>
              6.)  the board at P with the current move number <br>
              7.) Return the marked board — each square will be marked with the move number on which it is visited. <br>
              <br>
              <br>
              </p>
              
</html>
